# Critical Vulnerability: PCR Index Mismatch

## Severity: CRITICAL

**Type:** Logic Error / Assumption Violation  
**Location:** `src/EspressoNitroTEEVerifier.sol`, lines 78-79  
**Works with:** Secure TEE + Working ZK (if ZK doesn't validate PCR ordering)  
**Requires:** Malicious ZK circuit OR ZK circuit that doesn't validate PCR index field

## The Vulnerability

### Vulnerable Code

```solidity
// Lines 78-79: Assumes pcrs[0] is PCR index 0
bytes32 pcr0Hash = keccak256(abi.encodePacked(
    journal.pcrs[0].value.first,   // ‚Üê Assumes this is PCR0
    journal.pcrs[0].value.second
));

if (!registeredEnclaveHashes[service][pcr0Hash]) {
    revert InvalidEnclaveHash(pcr0Hash, service);
}
```

### What's Wrong

The code uses **array position** to identify PCR0, but PCRs have an **index field** that could be anything!

```solidity
struct Pcr {
    uint64 index;  // ‚Üê Could be 0, 1, 2, 3... but contract never checks!
    Bytes48 value;
}
```

## AWS Nitro PCR Overview

AWS Nitro Enclaves have multiple PCRs with different meanings:

| PCR | Measures | Security Importance |
|-----|----------|---------------------|
| PCR0 | Enclave image file | **CRITICAL** (code integrity) |
| PCR1 | Linux kernel & bootstrap | HIGH (OS integrity) |
| PCR2 | Application & init process | MEDIUM (app integrity) |
| PCR3 | Custom / Application-defined | LOW (varies) |
| PCR4+ | Reserved / Custom | VARIES |

**PCR0 is the MOST CRITICAL** - it proves the code integrity!

## The Attack

### Scenario: Malicious ZK Circuit

If the ZK circuit doesn't validate that `pcrs[0].index == 0`:

```rust
// Malicious or buggy ZK circuit:
fn create_journal(attestation: Attestation) -> Journal {
    // Returns PCRs in wrong order or with wrong indices
    Journal {
        pcrs: vec![
            Pcr { index: 3, value: attestation.pcr3 },  // Custom PCR
            Pcr { index: 0, value: attestation.pcr0 },  // Code (compromised!)
            Pcr { index: 1, value: attestation.pcr1 },  // Kernel (compromised!)
        ],
        ...
    }
}
```

**Your contract validates:**
```solidity
pcr0Hash = keccak256(journal.pcrs[0].value)  // Takes first element
         = keccak256(pcr3_value)              // But this is PCR3!

if (!registeredEnclaveHashes[service][pcr0Hash]) // Checks if PCR3 is registered
    revert;                                      // (Thinks it's PCR0!)
```

### Attack Steps

```
1. Attacker runs compromised TEE:
   - PCR0 (code): COMPROMISED [MALICIOUS]
   - PCR1 (kernel): COMPROMISED [MALICIOUS]  
   - PCR2 (app): COMPROMISED [MALICIOUS]
   - PCR3 (custom): Clean, benign value

2. Attacker's TEE generates attestation with all PCRs

3. Malicious ZK circuit reorders PCRs:
   journal.pcrs = [
       {index: 3, value: clean_pcr3},     // Position 0
       {index: 0, value: compromised_pcr0}, // Position 1  
       {index: 1, value: compromised_pcr1}, // Position 2
   ]

4. Your contract:
   - Reads journal.pcrs[0].value (the clean PCR3!)
   - Thinks it validated PCR0
   - Actually validated PCR3
   - Approves compromised TEE!

5. Result: COMPROMISED TEE IS APPROVED ‚ùå
```

## Proof of Concept Results

```
=== ATTACK: PCR INDEX MISMATCH ===

MALICIOUS JOURNAL:
  journal.pcrs[0].index = 3
  (Should be 0, but is 3!)

CONTRACT BEHAVIOR:
  Thinks it's validating: PCR0
  Actually validating: PCR3

[!] CRITICAL ISSUE:
  Contract validates wrong PCR!
  PCR0 (code) could be compromised!
```

## Why This is Critical

### 1. PCR0 is the Security Foundation

```
PCR0 = Hash of enclave code (binary)
     = Proves EXACTLY what code is running
     = Most important security measurement

If PCR0 validation is bypassed:
  ‚Üí Attacker can run ANY code
  ‚Üí Entire TEE security model fails
```

### 2. PCR3/Custom Can Be Anything

```
PCR3 (custom) can be:
  - Application-defined data
  - User-controlled values
  - Non-security-critical measurements
  
Validating PCR3 instead of PCR0:
  ‚Üí Like checking someone's favorite color
  ‚Üí Instead of checking their ID
```

### 3. Owner Can't Detect This

```
Owner registers hash thinking it's PCR0:
  setEnclaveHash(0xABC123, true, BatchPoster)
  
Owner thinks:
  "I approved code with hash 0xABC123"
  
Reality:
  "I approved PCR3=0xABC123, but PCR0 is unknown/compromised!"
```

## The Fix

### Add PCR Index Validation

```solidity
function _validateJournal(VerifierJournal memory journal) internal view {
    // Existing validations...
    require(journal.pcrs.length > 0, "PCR array cannot be empty");
    
    // ‚úÖ NEW: Validate that first PCR is actually PCR0!
    require(journal.pcrs[0].index == 0, "First PCR must be PCR0");
    
    // Existing public key validation...
    require(journal.publicKey.length == 65, "Invalid public key length");
    require(journal.publicKey[0] == 0x04, "Public key must be uncompressed");
}
```

### Enhanced Fix: Validate All Expected PCRs

```solidity
function _validateJournal(VerifierJournal memory journal) internal view {
    // Require at least PCR0, PCR1, PCR2
    require(journal.pcrs.length >= 3, "Must have at least 3 PCRs");
    
    // Validate PCR indices are correct
    require(journal.pcrs[0].index == 0, "pcrs[0] must be PCR0 (code)");
    require(journal.pcrs[1].index == 1, "pcrs[1] must be PCR1 (kernel)");
    require(journal.pcrs[2].index == 2, "pcrs[2] must be PCR2 (app)");
    
    // Optional: Validate PCRs are in ascending order
    for (uint256 i = 1; i < journal.pcrs.length; i++) {
        require(
            journal.pcrs[i].index > journal.pcrs[i-1].index,
            "PCRs must be in ascending order"
        );
    }
}
```

## Likelihood Assessment

### Depends on ZK Circuit Implementation

**If ZK circuit validates PCR ordering:**
```rust
// In SP1 circuit:
fn validate_pcrs(pcrs: &[Pcr]) -> Result<()> {
    ensure!(pcrs[0].index == 0, "First PCR must be 0");
    // ... more checks
    Ok(())
}
```
‚Üí Attack is **BLOCKED** at proof generation

**If ZK circuit does NOT validate PCR ordering:**
```rust
// In SP1 circuit:
fn create_journal(attestation: Attestation) -> Journal {
    // Just copies PCRs without validation
    Journal {
        pcrs: attestation.pcrs,  // ‚Üê No index validation!
        ...
    }
}
```
‚Üí Attack **SUCCEEDS**

## Risk Assessment

| Factor | Assessment |
|--------|------------|
| **Severity if exploitable** | CRITICAL |
| **Likelihood** | MEDIUM (depends on ZK circuit) |
| **Fix cost** | ~200 gas (1 require statement) |
| **Fix complexity** | TRIVIAL (1 line) |
| **Should you fix it?** | **ABSOLUTELY YES** |

## Defense in Depth Justification

**Even if ZK circuit validates PCR ordering, you should STILL add Solidity validation:**

1. ‚úÖ **200 gas cost is negligible**
2. ‚úÖ **Protects against circuit bugs**
3. ‚úÖ **Protects against circuit updates** that might remove validation
4. ‚úÖ **Makes assumption explicit** (self-documenting)
5. ‚úÖ **Prevents catastrophic failure** if circuit has gap

## Comparison: Before vs After

### Before (Vulnerable)

```
Contract assumes: pcrs[0] = PCR0
Reality: Could be ANY PCR!
Validation: WRONG PCR checked
Impact: Compromised TEE approved
```

### After (Fixed)

```
Contract validates: pcrs[0].index == 0
Reality: Must be PCR0 or transaction reverts
Validation: CORRECT PCR checked
Impact: Attack blocked
```

## Summary

**What:** Contract assumes PCR array position = PCR index  
**Where:** Lines 78-79  
**Impact:** Could validate wrong PCR, approve compromised TEE  
**Fix:** `require(journal.pcrs[0].index == 0, "First PCR must be PCR0");`  
**Cost:** ~200 gas  
**Priority:** HIGH - Add before production  

**This is a sneaky vulnerability that's easy to miss but has critical impact!** üéØ

