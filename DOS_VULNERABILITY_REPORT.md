# DoS Vulnerability Report: Unbounded Loop in deleteEnclaveHashes

## Severity: HIGH

## Vulnerability Type
Denial of Service (DoS) via Unbounded Loop / Gas Exhaustion

## Affected Code

**File:** `src/TEEHelper.sol`  
**Lines:** 92-111  
**Function:** `deleteEnclaveHashes()`

```solidity
function deleteEnclaveHashes(bytes32[] memory enclaveHashes, ServiceType service)
    external
    virtual
    onlyOwner
{
    for (uint256 i = 0; i < enclaveHashes.length; i++) {
        // also delete all the corresponding signers from registeredService mapping
        EnumerableSet.AddressSet storage signersSet =
            enclaveHashToSigner[service][enclaveHashes[i]];
        while (signersSet.length() > 0) {  // ← UNBOUNDED LOOP
            address signer = signersSet.at(0);
            delete registeredServices[service][signer];
            // slither-disable-next-line unused-return
            signersSet.remove(signer);
            emit DeletedRegisteredService(signer, service);
        }
        delete registeredEnclaveHashes[service][enclaveHashes[i]];
        emit DeletedEnclaveHash(enclaveHashes[i], service);
    }
}
```

## Root Cause

The function uses an unbounded `while` loop that iterates through all signers associated with an enclave hash. If an enclave hash has a large number of registered signers, the gas required to execute this loop can exceed the block gas limit, making the function uncallable.

### Gas Consumption Analysis

Each iteration of the while loop performs:
- `signersSet.at(0)`: ~2,000 gas
- `delete registeredServices`: ~5,000 gas (SSTORE refund)
- `signersSet.remove()`: ~20,000 gas (storage operations + set rebalancing)
- `emit DeletedRegisteredService`: ~1,500 gas

**Total per iteration:** ~28,500 gas

**Block gas limit (Ethereum):** 30,000,000 gas  
**Maximum deletable signers:** ~1,050 signers per transaction

If an enclave hash has more than ~1,000 registered signers, the transaction will run out of gas and revert.

## Attack Scenario

### Step 1: Attacker Registers Many Services

```solidity
// Attacker uses same enclave hash for many registrations
bytes32 maliciousEnclaveHash = 0x...;

// Owner sets this hash as valid
setEnclaveHash(maliciousEnclaveHash, true, ServiceType.BatchPoster);

// Attacker registers 5,000 different addresses
for (uint i = 0; i < 5000; i++) {
    // Each registration adds to enclaveHashToSigner[service][hash]
    registerService(...); // Different signer each time
}
```

### Step 2: Hash Becomes Compromised

```
Owner discovers that maliciousEnclaveHash corresponds to a compromised TEE
```

### Step 3: Owner Cannot Delete Hash

```solidity
// Owner tries to remove compromised hash
bytes32[] memory hashes = new bytes32[](1);
hashes[0] = maliciousEnclaveHash;

// ❌ REVERTS: Out of Gas
deleteEnclaveHashes(hashes, ServiceType.BatchPoster);
```

### Step 4: System Impact

- ✅ Compromised enclave hash **cannot be removed**
- ✅ All 5,000 malicious signers **remain valid**
- ✅ Attacker can continue using compromised services
- ✅ Owner must keep the compromised hash active or DoS the system

## Impact Assessment

### Direct Impact
1. **Owner cannot remove compromised enclave hashes** if they have too many signers
2. **Permanent security vulnerability** - compromised TEEs remain trusted
3. **Administrative DoS** - critical security functions become unusable

### Cascading Impact
1. If an attacker deliberately inflates signer count, they can **lock in** a compromised enclave hash
2. Owner's only option is to disable the hash via `setEnclaveHash(hash, false)`, but:
   - Previously registered signers **remain valid** in `registeredServices` mapping
   - The signers can still pass verification checks
3. System integrity is permanently compromised

### Realistic Attack Cost

**Prerequisites:**
- Valid attestation from a legitimate TEE
- Ability to register multiple times

**Cost per registration (Arbitrum One example):**
- Gas: ~200,000 per registration
- At $0.01 per 1M gas: $0.002 per registration
- **Total for 5,000 registrations: ~$10**

This is an economically viable attack!

## Proof of Concept

### Scenario 1: Legitimate Use Case DoS

```solidity
// A popular enclave version is used by 2,000 different services
bytes32 popularHash = 0x...;

// Over time, 2,000 services register
for (uint i = 0; i < 2000; i++) {
    registerService(...); // Different services using same enclave
}

// Security vulnerability discovered in this enclave version
// Owner needs to remove it urgently

bytes32[] memory hashes = new bytes32[](1);
hashes[0] = popularHash;

// ❌ Transaction fails - too many signers to delete
deleteEnclaveHashes(hashes, ServiceType.BatchPoster);
```

### Scenario 2: Malicious Inflation Attack

```solidity
// Attacker discovers a way to cheaply register many services
bytes32 attackHash = 0x...;

// Attacker registers 10,000 services
for (uint i = 0; i < 10000; i++) {
    // Generate new key pair in TEE each time
    registerService(...);
}

// Later, this enclave is compromised
// Owner discovers vulnerability but CANNOT remove it
// All 10,000 malicious signers remain permanently valid
```

## Current Mitigations (None)

The contract has:
- ❌ No limit on signers per enclave hash
- ❌ No batch deletion mechanism
- ❌ No way to disable signers without deleting the hash
- ❌ No circuit breaker for emergency situations

## Recommended Fix

### Solution 1: Batched Deletion with Cursor (Recommended)

Modify the function to process deletions in batches across multiple transactions:

```solidity
/**
 * @notice Deletes signers associated with an enclave hash in batches
 * @param enclaveHash The hash to clean up
 * @param service The service type
 * @param maxIterations Maximum number of signers to delete in this call (e.g., 100)
 * @return remaining Number of signers still remaining
 */
function deleteEnclaveHashBatch(
    bytes32 enclaveHash, 
    ServiceType service,
    uint256 maxIterations
) external onlyOwner returns (uint256 remaining) {
    EnumerableSet.AddressSet storage signersSet = 
        enclaveHashToSigner[service][enclaveHash];
    
    uint256 iterations = 0;
    while (signersSet.length() > 0 && iterations < maxIterations) {
        address signer = signersSet.at(0);
        delete registeredServices[service][signer];
        signersSet.remove(signer);
        emit DeletedRegisteredService(signer, service);
        iterations++;
    }
    
    remaining = signersSet.length();
    
    // Only delete the hash if all signers are removed
    if (remaining == 0) {
        delete registeredEnclaveHashes[service][enclaveHash];
        emit DeletedEnclaveHash(enclaveHash, service);
    }
    
    return remaining;
}

/**
 * @notice Legacy function - now processes in batches
 * @dev This will need multiple transactions if signers > maxBatchSize
 */
function deleteEnclaveHashes(
    bytes32[] memory enclaveHashes, 
    ServiceType service
) external virtual onlyOwner {
    uint256 maxBatchSize = 100; // Safe batch size
    
    for (uint256 i = 0; i < enclaveHashes.length; i++) {
        uint256 remaining = this.deleteEnclaveHashBatch(
            enclaveHashes[i], 
            service, 
            maxBatchSize
        );
        
        require(
            remaining == 0, 
            "Hash has too many signers. Call deleteEnclaveHashBatch multiple times."
        );
    }
}
```

### Solution 2: Two-Step Deletion Process

```solidity
// Step 1: Disable the hash (immediate)
function disableEnclaveHash(bytes32 enclaveHash, ServiceType service) 
    external 
    onlyOwner 
{
    registeredEnclaveHashes[service][enclaveHash] = false;
    emit EnclaveHashDisabled(enclaveHash, service);
}

// Step 2: Clean up signers in batches (can be done over multiple transactions)
function cleanupSignersBatch(
    bytes32 enclaveHash,
    ServiceType service,
    uint256 maxIterations
) external onlyOwner returns (uint256 remaining) {
    require(
        !registeredEnclaveHashes[service][enclaveHash],
        "Hash must be disabled first"
    );
    
    EnumerableSet.AddressSet storage signersSet = 
        enclaveHashToSigner[service][enclaveHash];
    
    uint256 iterations = 0;
    while (signersSet.length() > 0 && iterations < maxIterations) {
        address signer = signersSet.at(0);
        delete registeredServices[service][signer];
        signersSet.remove(signer);
        emit DeletedRegisteredService(signer, service);
        iterations++;
    }
    
    return signersSet.length();
}
```

### Solution 3: Add Maximum Signers Per Hash Limit

```solidity
uint256 public constant MAX_SIGNERS_PER_HASH = 1000;

function registerService(...) external {
    // ... existing validation ...
    
    // Check signer limit
    EnumerableSet.AddressSet storage signersSet = 
        enclaveHashToSigner[service][pcr0Hash];
    
    require(
        signersSet.length() < MAX_SIGNERS_PER_HASH,
        "Maximum signers for this enclave hash reached"
    );
    
    // ... proceed with registration ...
}
```

## Recommended Implementation

**Implement ALL three solutions:**

1. **Solution 1 (Batched Deletion)** - Fixes the immediate DoS
2. **Solution 2 (Two-Step Process)** - Provides emergency response capability
3. **Solution 3 (Signer Limit)** - Prevents the attack from happening

### Migration Path

1. Deploy new contract with fixes
2. For existing hashes with many signers:
   - Use `disableEnclaveHash()` to immediately stop new registrations
   - Use `cleanupSignersBatch()` over multiple transactions to clean up
3. Monitor signer counts and alert if approaching limits

## Testing Recommendations

```solidity
// Test 1: Verify batch deletion works
function testBatchDeletion() {
    // Register 500 signers
    // Delete in batches of 100
    // Verify all deleted after 5 calls
}

// Test 2: Verify gas consumption is bounded
function testGasBounded() {
    // Register 100 signers
    // Measure gas for batch delete
    // Assert gas < reasonable limit (e.g., 5M)
}

// Test 3: Verify max signers limit works
function testMaxSignersLimit() {
    // Register MAX_SIGNERS_PER_HASH signers
    // Attempt one more registration
    // Verify it reverts
}
```

## Timeline

- **Severity:** HIGH
- **Exploitability:** MEDIUM (requires legitimate TEE access initially)
- **Impact:** HIGH (permanent security vulnerability)
- **Recommended Action:** Patch within 30 days
- **Emergency Action:** Add monitoring for signer counts immediately

## References

- Similar vulnerability: [Bancor Network unbounded iteration DoS](https://blog.bancor.network/bancor-network-vulnerability-disclosure-28-08-2020-9a57a5e5b2c7)
- Gas optimization guide: [Solidity Gas Optimization](https://github.com/iskdrews/awesome-solidity-gas-optimization)

